/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.MCG.iu;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import sm.MCG.graficos.MContorno;
import sm.MCG.graficos.MCurva;
import sm.MCG.graficos.MElipse;
import sm.MCG.graficos.MLinea;
import sm.MCG.graficos.MRectangulo;
import sm.MCG.graficos.MFiguras;
import sm.MCG.graficos.MFigurasRelleno;
import sm.MCG.graficos.MLuna;
import sm.MCG.graficos.MRelleno;
import sm.MCG.graficos.MTrazoLibre;

/**
 * Clase Lienzo2D, hereda de JPanel, genera el lienzo y las diferentes figuras
 * Da la funcionalidad y los atributos a las figuras e interactua con las diferentes clases fuera de nuestra biblioteca.
 * @author mati
 */
public class Lienzo2D extends javax.swing.JPanel {


    /**
     * Crea una nueva forma Lienzo2D.
     * Atributos de las figuras la inicializa por defecto.
     */
    public Lienzo2D() {
        initComponents();
        pAux = new Point(-500,-500);
        dibujo = Dibujo.enum_linea;
        vShape = new ArrayList();
        mover = Boolean.FALSE; 
        shapeaux = (MFiguras) new MLinea( pAux);
        puntoControl = false ;
        atributosContorno = new MContorno();
        atributosRelleno = new MRelleno();   
        colorContorno= colorRelleno= colorDegradado = Color.BLACK;
        relleno = sidegradado =transcompo=alisarRend=taerFrente=enviarFondo=enviarAtras=traerDelante= Boolean.FALSE;
        opcionDegradado  = 0;
        cap = 3; // 3 representa la linea continua
        grosor = 2;
        gradoTransparencia = 0.50F;
        composicion = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f);
        render = new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);

        
    }
    
    /**
     * Crea el fondo blanco y el marco del lienzo.
     * @param g, Graphics para pintar el lienzo.
     * @param ancho, El ancho del lienzo.
     * @param alto, El alto del lienzo.
     */
    public void marcoLienzo(Graphics g,double ancho,double alto){
        super.paint(g);
        Graphics2D g2d = (Graphics2D)g;
        clipLienzo = new Rectangle(); 
        clipLienzo.setRect(0,0, ancho,alto);
        g2d.setPaint(Color.DARK_GRAY);
        Stroke trazo; 
        float patronaux[] = {15.0f, 15.0f};
        trazo = new BasicStroke(5.0f,BasicStroke.CAP_ROUND,BasicStroke.JOIN_MITER, 1.0f,patronaux, 0.0f);
        g2d.setStroke(trazo);            
        g2d.setClip(clipLienzo);
        g2d.draw(clipLienzo);
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Captura el primer punto cuando clicas en el raton.
     * @param evt 
     */
    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        pAux = evt.getPoint(); 
    }//GEN-LAST:event_formMouseClicked

    /**
     * Gestion de las figuras mientras mantenemos el ratón con el click activo.
     * @param evt, segundo punto de la figura a dibujar, 
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        pAux = evt.getPoint();
        if(mover){
            shapeaux = this.getSelectedShape(evt.getPoint());
            if(shapeaux!=null)
                pAux = new Point2D.Double(shapeaux.getLocation().getX()-evt.getPoint().getX(),shapeaux.getLocation().getY()-evt.getPoint().getY());// si ya tenemos figura, el punto será donde hemos clicado menos la localizacion de la figura
               //Gestión del movimiento de unas figuras con otras. 
                if(taerFrente){
                    this.taerFrente(getSelectedShape(evt.getPoint()));
                }else if(enviarFondo){
                    this.enviarFondo(getSelectedShape(evt.getPoint()));
                }else if(enviarAtras){
                    this.enviarAtras(getSelectedShape(evt.getPoint()));
                }else if(traerDelante){
                    this.traerDelante(getSelectedShape(evt.getPoint()));
                }
        }else{
            if(shapeaux!=null){
                if(shapeaux instanceof MCurva && !puntoControl){
                    puntoControl = true ;
                }else{
                    puntoControl = false ;
                }
            }
            if(!puntoControl || shapeaux==null){
                createShape(evt.getPoint());
            }          
        }
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
       formMouseDragged(evt);
    }//GEN-LAST:event_formMouseReleased

    /**
     * Gestion de las figuras mientras arrastramos el ratón con el click activo.
     * @param evt, segundo punto de la figura a dibujar, 
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if(mover){
            if(shapeaux !=null){
                Point2D punto;
                punto = new Point2D.Double(evt.getPoint().getX() + pAux.getX(),evt.getPoint().getY() + pAux.getY());
                shapeaux.setLocation(punto);
            } 
        }else if(shapeaux !=null){
            //punto de control de la Mcurva
            if(shapeaux instanceof MCurva ){
                if(puntoControl){
                ((MCurva)shapeaux).setPuntoControl(evt.getPoint());
                }else{
                    shapeaux.updateShape(evt.getPoint());
                }
            }else{
                shapeaux.updateShape(evt.getPoint());
            } 
        }
        repaint();
    }//GEN-LAST:event_formMouseDragged
   
    /**
     * Setter para darle ancho al lienzo, varia según la imagen a enmarcar.
     * @param a, double, El ancho del nuevo lienzo.
     */
    public void setAncho(double a){
        ancho=a;
    }
    
    /**
     * Setter para darle alto al lienzo, varia según la imagen a enmarcar.
     * @param a, double, El alto del nuevo lienzo.
     */
    public void setAlto(double a){
        alto =  a;
    }
    
    /**
     * Setter para decir si estas guardando la imagen o el lienzo en cuyo caso quitamos el marco.
     * @param guardo, booleano que representa la opción elegida.
     */
    public void setGuardar(boolean guardo){
        guardar = guardo;
    }
    
    /**
     * Getter que nos dice que opcion hemos elegido a la hora de guardar una imagen con o sin marco.
     * @return boolean que nos dice la opción elegida.
     */
    public boolean getGuardar(){
        return guardar;
    }
    
    /**
     * Pinta el fondo del lienzo, las diferentes figuras, cada una con sus atributos
     * enmarca la figura seleccionada en cada momento cuando activamos dicha opcion.
     * @param g, El modelo geometrico para las diferentes figuras.
     */
    @Override
    public void paint(Graphics g){
        super.paint(g);
        if(!guardar){
            marcoLienzo(g, ancho, alto); // marco del lienzo
        }
        Graphics2D g2d = (Graphics2D)g;
        for(MFiguras s:vShape) { 
            s.paint(g2d); 
            //enmarca la figura seleccionada.
            if (mover && s == this.getSelectedShape(pAux)) { 
                clipArea = new Rectangle(); 
                clipArea.setRect(s.getBounds2D().getMinX()-10.0F, s.getBounds2D().getMinY()-10.0F, s.getBounds2D().getWidth()+20.0F, s.getBounds2D().getHeight()+20.0F);
                g2d.setPaint(Color.DARK_GRAY);
                Stroke trazo; 
                float disaux[] = {15.0f, 15.0f};
                trazo = new BasicStroke(1.0f,BasicStroke.CAP_ROUND,BasicStroke.JOIN_MITER, 1.0f,disaux, 0.0f);
                g2d.setStroke(trazo);    
                g2d.draw(clipArea); 
            }
        }
    }

    /**
     * Setter del color del contorno
     * @param color, El nuevo color del contorno
     * Si hay una figura seleccionada le da su propio color de contorno
     */ 
    public void setColorContorno(Color color){
       this.colorContorno = color ;
       if(shapeaux!=null){
            shapeaux.setColorContorno(color);
       }
        repaint();
    }
    
    /**
     * Getter del color del contorno
     * @return Color, El color del contorno activo del lienzo.
     */
    public Color getColorContorno(){
        return colorContorno;
    }
    
    /**
     * Setter del color del relleno
     * @param color, El nuevo color del relleno.
     * Si hay una figura seleccionada le da su propio color de relleno.
     */ 
    public void setColorRelleno(Color color){
       this.colorRelleno=color;
       if(shapeaux!=null){
            shapeaux.setColorRelleno(color);
       }
        repaint();
    }
    
    /**
     * Getter del color del relleno actual
     * @return Color, El color del relleno activo del lienzo.
     */
    public Color getColorRelleno(){
        return colorRelleno;
    }
    
    /**
     * Setter del color del degradado
     * @param color, El nuevo color del degradado
     * Si hay una figura seleccionada le da su propio color de degradado.
     */
    public void setColorDegradado(Color color){
       this.colorDegradado = color;
       if(shapeaux!=null){
            shapeaux.setColorDegradado(color);
       }
        repaint();
    }
    
    /**
     * Getter del color del degradado
     * @return Color , El color del degradado activo del lienzo. 
     */
    public Color getColorDegradado(){
        return colorDegradado;
    }
    
    /**
     * Setter de las opciones del degradado
     * @param option, La nueva opción del tipo de degradado, pudiendo ser horizontal(0), vertical(1) o inclinado(2)
     * Si hay una figura seleccionada le da su propia opcion del tipo de degradado.
     */
    public void opcionDegradado(int option){
       opcionDegradado = option;
       if(shapeaux!=null){
            shapeaux.setOpcionDegradado(option);
       }
        repaint();
    }
    
    /**
     * Setter de si hay degradado o no
     * @param si, Booleano que nos dice si hay o no degradado.
     * Si hay una figura seleccionada le da su propia opcion de si hay o no degradado
     */
    public void SetSiDegradado(boolean si){
        sidegradado=si;
        if(shapeaux!=null){
            shapeaux.SetSiDegradado(si);
       }
        repaint();
    }
    
    /**
     * Setter del Dibujo, tipo de dibujo que queremos pintar.
     * @param enumerado, El enumerado que representa la figura a dibujar. 
     * Reinicia o pone a null la figura seleccionada.
     */
    public void setDibujo(Enum enumerado){
        this.dibujo = enumerado;
         shapeaux=null;
    }
    
    /**
     * Getter del Dibujo, Figura activa en el lienzo.
     * @return Enum que representa la figura activa del lienzo.
     */
    public Enum getDibujo(){
        return dibujo;
    }
    
    /**
     * Setter de los atributos del contorno de la figura a digujar
     * @param cont, El contorno de la figura.
     */
    public void setContorno(MContorno cont){
        this.atributosContorno = cont;
    } 
    
    /**
     * Setter de los atributos del relleno de la figura a digujar
     * @param rell, El relleno de la figura.
     */
    public void setRelleno(MRelleno rell){
        this.atributosRelleno = rell ;
    }
    
    /**
     * Getter de la propia clase, MContorno
     * @return MContorno, La clase contorno con todos sus atributos
     * Si tenemos activa la opcion de mover y tenemos una figura seleccionada, devuelve su contorno 
     * devuelve null si no tenemos figura seleccinada
     * devuelve los propios atributos de contorno del lienzo sin la opcion mover.
     */
    public MContorno getContorno(){
        if(mover){ 
            if(shapeaux != null){
                return shapeaux.getContorno();
            }else{
                return null;
            }
        }else{
            return atributosContorno;
        }
    }
    
    /**
     * Getter de la propia clase, MRelleno
     * @return MRelleno, La clase relleno con todos sus atributos
     * Si tenemos activa la opcion de mover y tenemos una figura seleccionada, devuelve su relleno 
     * devuelve null si no tenemos figura seleccinada
     * devuelve los propios atributos de contorno del lienzo sin la opcion mover.
     */
    public MRelleno getRelleno(){
        if(mover){ 
            if(shapeaux != null){
                return shapeaux.getRelleno();
            }else{
                return null;
            }
        }else{
            return atributosRelleno;
        }
    }
    
    /**
     * Setter para adjudicar si la figura contendrá relleno.
     * @param booleano, Booleano que nos dice si hay o no relleno. 
     * Si tenemos una figura activa le manda el mensaje a su propia clase.
     */ 
    public void setBoolRelleno(Boolean booleano){
        relleno = booleano;
        if(shapeaux!=null){
            shapeaux.setBoolRelleno(booleano);
        }
        repaint();
    }
    
    /**
     * Getter para darle la opcion de tener relleno.
     * @return booleano, Booleano que nos permite saber si tenemos o no relleno.
     * Si tenemos activa la opcion de mover y tenemos una figura seleccionada, devuelve su opcion de relleno. 
     * devuelve null si no tenemos figura seleccinada
     * sin la opcion mover devuelve el relleno del lienzo.
     */
    public boolean getBoolRelleno(){
        if(mover){ 
            if(shapeaux != null){
                return shapeaux.getBoolRelleno();
            }else{
                return false;
            }
        }else{
            return relleno;
        }
    }
    
    /**
     * Setter del grosor del trazo del lienzo
     * @param nuevo, El nuevo grosor del trazo del lienzo, y de la figura si esta activa.
     */
    public void setGrosor(int nuevo){
        grosor= nuevo;
        if(shapeaux!=null){
            shapeaux.setGrosor(nuevo);
        }
        repaint();
    }
    
    /**
     * Getter del grosor del trazo del lienzo
     * @return int, grosor del trazo del lienzo.
     */
    public int getGrosor(){
        return grosor;
    }
    
    /**
     * Setter del valor de la decoración, atributo del trazo o contorno del lienzo.
     * @param continua, int que indica el tipo de decoracion de la discontinuidad
     * si tenemos una figura activa manda la información a la misma.
     */
    public void setDiscontinuidad(int continua){
        cap=continua;
        if(shapeaux!=null){
            shapeaux.setDiscontinuidad(continua);
        }
        repaint();   
    }
    
    /**
     * Setter de la variable patron de la discontinuidad del lienzo, separación del trazo cuando es discontinua.
     * @param patron, El nuevo valor del patron, separación del entrelineado. 
     * si tenemos una figura activa manda la información a la misma.
     */
    public void setPatronDiscontinuidad(int patron){
        float aux[] = {(float)patron, (float)patron};
        patronDiscontinuidad = aux ;
        if(shapeaux!=null){
            shapeaux.setPatronDiscontinuidad(patron);
        }
        repaint();
    }
    
    /**
     * Getter del boleano que representa la transparencia de la figura en el lienzo
     * @return booleano, Devuelve si la transparencia del lienzo está activa o no 
     */
    public boolean getCompo(){
        return transcompo;
    }
    
    public void setCompo(boolean trans){
        transcompo = trans;
    }
    
    /**
     * Getter de la Composicion, transparencia de la figura del lienzo.
     * @return Composite, La composicion de la figura del lienzo
     */
    public Composite getComposicion(){
        return composicion;
    }
    
    /**
     * Setter de la Composicion, transparencia de la figura del lienzo.
     * @param transparencia, Determina si hay transparencia o no, si es que si la inicializa a un grado por defecto
     * Si hay una figura activa manda la orden a la misma.
     */
    public void setComposicion(boolean transparencia){
        if(transparencia){
            composicion = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f);
        }else{
            composicion =  AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f);
        }
        transcompo = transparencia;
        if(shapeaux!=null){
            shapeaux.setComposicion(transparencia);
        }
        repaint();
    }
    
    /**
     * Setter del grado de transparencia de la figura en el lienzo
     * @param grado, El nuevo grado de transparencia del lienzo.
     * Si hay una figura activa le envia su grado de transparencia.
     */
    public void gradoTransparencia(int grado){
        gradoTransparencia = (float)grado/100;
        composicion =  AlphaComposite.getInstance(AlphaComposite.SRC_OVER, gradoTransparencia);
        if(shapeaux!=null){
            shapeaux.gradoTransparencia(grado);
        }
        repaint();
    }
    
    /**
     * Getter del booleano que representa renderizado del lienzo.
     * @return boolean, Determina si está activo el renderizado del lienzo.
     */
    public boolean getRender(){
        return alisarRend;
    }
    /**
     * Getter del renderizado del lienzo.
     * @return renderinghints, El renderizado del lienzo.
     */
    public RenderingHints getAlisar(){
        return render;
    }

    /**
     * Setter del renderizado del lienzo
     * @param alisar, Booleano que nos dice si hay o no rendering.
     * Si tenemos una figura activa manda la orden de renderizar.
     */
    public void setRender(boolean alisar){
        if(alisar){
            render = new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
        }else{
            render = new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
        }
        alisarRend = alisar ;
        if(shapeaux!=null){
            shapeaux.setRender(alisar);
        }
        repaint();
    }
    
    /**
     * Getter que nos dice si el lienzo va a pintar o a tratar una figura.
     * pudiendo cambiar sus atributos o moverla de sitio en el lienzo.
     * @return booleano, variable que representa si editamos la figura.
     */
    public Boolean getEditar(){   
        return mover;
    }
    
    /**
     * Setter de la opcion editar del lienzo
     * @param editar ,booleano que le asigna al lienzo la opcion de mover o editar una figura.
     */
    public void setEditar(boolean editar){
        mover = editar ;
    }
    /**
     * Getter de la opción traer la figura al frente del resto.
     * @return booleano que representa la opcion de traer la figura al frente de todas en el lienzo.
     */
    public Boolean getTraerFrente(){
        return taerFrente;
    }
    
    /**
     * Setter de la opcion traer la figura al frente de todas.
     * @param editar, booleano que le asigna al lienzo la opcion de mover la figura seleccionada al frente de todas 
     */
    public void setTraerFrente(boolean editar){
        taerFrente = editar ;
    }
    
    /**
     * Getter de la opción enviar la figura al fondo.
     * @return booleano que representa la opcion de enviar la figura al fondo de todas en el lienzo.
     */
    public Boolean getEnviarFondo(){
        return enviarFondo;
    }
    
    /**
     * Setter de la opcion enviar la figura detras de todas.
     * @param editar, booleano que le asigna al lienzo la opcion de mover la figura seleccionada detras de todas 
     */
    public void setEnviarFondo(boolean editar){
        enviarFondo = editar ;
    }
    
    /**
     * Getter de la opción enviar la figura una posicion atras de la actual.
     * @return booleano que representa la opcion de enviar la figura una posicion atras de la actual en el lienzo.
     */
    public Boolean getEnviarAtras(){
        return enviarAtras;
    }
    
    /**
     * Setter de la opcion de enviar la figura una posición atras de la actual.
     * @param editar, booleano que le asigna al lienzo la opcion de mover la figura seleccionada una posición atras de la actual
     */
    public void setEnviarAtras(boolean editar){
        enviarAtras = editar ;
    }
    
    /**
     * Getter de la opción enviar la figura una posicion delante de la actual.
     * @return booleano que representa la opcion de enviar la figura una posicion delante de la actual en el lienzo.
     */
    public Boolean getTraerDelante(){
        return traerDelante;
    }
    
    /**
     * Setter de la opcion de enviar la figura una posición hacia delante de la actual.
     * @param editar, booleano que le asigna al lienzo la opcion de mover la figura seleccionada una posición hacia delante de la actual
     */
    public void setTraerDelante(boolean editar){
        traerDelante = editar ;
    }    
    
    /**
     * Getter de la figura que contiene el punto pasado por parametro.
     * @param p, El punto que es contenido por la figura.
     * @return la figura que contiene el punto o null si no hay ninguna en ese punto.
     */
    private MFiguras getSelectedShape(Point2D p){
        for(MFiguras s:vShape)
            if(s.contains(p)) return s;
        return null;
    }
    
    /**
     * Trae la figura al frente del resto
     * @param mifigura 
     */
    private void taerFrente(MFiguras mifigura) {
        vShape.remove(mifigura);
        vShape.add(vShape.size(), mifigura) ;
    }
    
    /**
     * Envia la figura al fondo, detras del resto
     * @param mifigura 
     */
    private void enviarFondo(MFiguras mifigura) {
        vShape.remove(mifigura);
        vShape.add(0, mifigura) ;
    }
    
    /**
     * Envia la figura una posicion detras de la actual
     * @param mifigura 
     */
    private void enviarAtras(MFiguras mifigura) {
        int indice = vShape.indexOf(mifigura)-1;
        vShape.remove(mifigura);
        vShape.add(indice, mifigura) ;
    }
    
    /**
     * Envia la figura una posicion delante de la actual
     * @param mifigura 
     */
    private void traerDelante(MFiguras mifigura) {
        int indice = vShape.indexOf(mifigura)+1;
        vShape.remove(mifigura);
        vShape.add(indice, mifigura) ;
    }
    
    /**
     * Getter de la figura actual.
     * @return MFiguras, la figura activa en el lienzo.
     */
    public MFiguras getMFiguras(){
        if(!(shapeaux instanceof MFigurasRelleno) && shapeaux!=null){
            this.relleno=shapeaux.getBoolRelleno();
            this.sidegradado =shapeaux.getSiDegradado();
            this.transcompo=shapeaux.getCompo();
            this.alisarRend=shapeaux.getRender();
        }
        return shapeaux;
    }
    
    /**
     * Setter de la figura activa en el lienzo.
     * @param actual, La figura activa en el lienzo.
     */
    public void setMFiguras(MFiguras actual){
        shapeaux = actual ;
    }
    
    /**
     * Metodo que crea la figura activa en el lienzo, pasandole sus atributos contorno y relleno si lo tuviera.
     * @param evt, punto a partir del cual se crean las figuras.
     */
    private void createShape(Point evt){
        MRelleno rell;
        MContorno conto ;
        
        if(this.getDibujo()==Dibujo.enum_linea){
            shapeaux = (MFiguras) new MLinea(evt,evt);
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            vShape.add( shapeaux);
        }else if(this.getDibujo()==Dibujo.enum_rectangulo){
            shapeaux = (MFiguras) new MRectangulo(evt,evt); 
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            rell = new MRelleno(colorRelleno, colorDegradado,this.relleno, this.sidegradado,this.opcionDegradado);
            shapeaux.setRelleno(rell);
            vShape.add(shapeaux);
        }else if(this.getDibujo() == Dibujo.enum_elipse){
            shapeaux = (MFiguras) new MElipse(evt,evt);
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            rell = new MRelleno(colorRelleno, colorDegradado,this.relleno, this.sidegradado,this.opcionDegradado);
            shapeaux.setRelleno(rell);
            vShape.add(shapeaux); 
        }else if(this.getDibujo()==Dibujo.enum_curva){
            shapeaux = (MFiguras) new MCurva(evt,evt);
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            vShape.add( shapeaux);
        }else if(this.getDibujo()==Dibujo.enum_trazoLibre){
            shapeaux = (MFiguras) new MTrazoLibre(evt,evt);
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            vShape.add(shapeaux);
        }else if(this.getDibujo() == Dibujo.enum_propio){
            shapeaux = (MFiguras) new MLuna(evt);
            conto = new MContorno(colorContorno, transcompo,gradoTransparencia, alisarRend, grosor, cap,patronDiscontinuidad);
            shapeaux.setContorno(conto);
            rell = new MRelleno(colorRelleno, colorDegradado,this.relleno, this.sidegradado,this.opcionDegradado);
            shapeaux.setRelleno(rell);
            vShape.add(shapeaux); 
        }
    }
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    /**
     * Punto de apoyo donde se inician todas las figuras.
     */
    private Point2D pAux;
    
    /**
     * Enumerado que determina que dibujo queremos pintar.
     */
    private Enum dibujo ;
    
    /**
     * Booleano que nos dice si movemos o editamos las figuras.
     */
    private Boolean  mover;
    
    /**
     * Array contenedor de todas nuestras figuras.
     */
    private ArrayList<MFiguras> vShape;
    
    /**
     * Figura actual seleccionada.
     */
    private MFiguras shapeaux; 
    
    /**
     * Booleanos que determinan la posición de la figura seleccionada dentro del array.
     */
    private boolean puntoControl, taerFrente,enviarFondo,enviarAtras,traerDelante;
    
    /**
     * MAtributos que representan el contorno y el relleno de la figura en el lienzo.
     */
    private MContorno atributosContorno;
    private MRelleno atributosRelleno ;
    
    /**
     * Colores del contorno, relleno y degradado de la figura en el lienzo.
     */
    private Color colorContorno, colorRelleno, colorDegradado ;
    
    /**
     * Booleanos de las opciones de los atributos de la figura en el lienzo.
     */
    private Boolean relleno ,sidegradado,transcompo,alisarRend;
    
    /**
     * Rectangulos que rodean las figuras seleccionadas en el lienzo
     * Rectangulo del marco del lienzo.
     */
    private Rectangle2D clipArea,clipLienzo;
    
    /**
     * Opciones del tipo de degradado de la figura en el lienzo
     * Grosor del trazo de la figura en el lienzo
     * Cap, tipo de linea del contorno de la figura, 3 por defecto, representa la linea continua.
     */
    private int opcionDegradado, grosor, cap ;
    
    /**
     * Grado de transparencia de la figura en el lienzo.
     */
    private float gradoTransparencia;
    
    /**
     * Patron de discontinuidad de la figura en el lienzo.
     */
    private float patronDiscontinuidad[] = {15.0f, 15.0f};
    
    /**
     * Composición (transparencia) de la figura en el lienzo.
     */
    private Composite composicion;
    
    /**
     * RenderingHints de la figura en el lienzo.
     */
    private RenderingHints render;
    
    /**
     * Double que representa el ancho del lienzo.
     */
    private double ancho ;
    
    /**
     * Alto del tamaño del lienzo.
     */
    private double alto ;
    
    /**
     * Booleano que me permite dejar el marco o quitarlo segun esté creando la imagen o guardandola.
     */
    private boolean guardar = false;
}
